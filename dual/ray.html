<!-- Copyright 2010 Robert Scott Dionne. All Rights Reserved. -->
<html>
  <head>
    <script src="base.js" type="application/javascript"></script>
    <script id="v0" type="x-shader/x-vertex">
      precision mediump float;

      uniform vec3 translate;
      attribute vec3 position;
      varying vec3 ray;

      void main() {
        mat4 t = mat4(1.0);
        t[3][0] = translate.x;
        t[3][1] = translate.y;
        t[3][2] = translate.z;
        mat4 p = mat4(1.0);
        p[2][2] = -1001.0 / 999.0;
        p[2][3] = -1.0;
        p[3][2] = -2000.0 / 999.0;
        p[3][3] = 0.0;
        vec4 d = t * vec4(position, 1);
        ray = d.xyz;
        gl_Position = p * d;
      }
    </script>
    <script id="f0" type="x-shader/x-fragment">
      precision mediump float;

      uniform bool debug;
      uniform bool eyeTrackingLod;
      uniform int distanceFn;
      uniform vec3 translate;
      varying vec3 ray;

      float distance(vec3 pos);
      vec3 gradient(vec3 pos);
      vec3 exactGradient(vec3 pos);
      vec3 approximateGradient(vec3 pos);

      float r = 0.22;
      float R = 0.5;
      void main() {
        vec3 pos = vec3(ray);
        vec3 dir = normalize(ray);
        float eps;
        if (eyeTrackingLod) {
          eps = 1.001 - dot(normalize(dir*vec3(.25,.25,1.)), vec3(0.0, 0.0, -1.0));
        } else {
          eps = 0.001;
        }
        bool hit = false;
        float count = 0.0;
        vec3 p;
        mat4 proj = mat4(1.0);
        proj[2][2] = -1001.0 / 999.0;
        proj[2][3] = -1.0;
        proj[3][2] = -2000.0 / 999.0;
        proj[3][3] = 0.0;
        for(int i = 0; i < 100; ++i) {
          if (abs(pos-translate).x > 1.1) {
            break;
          }
          if (abs(pos-translate).y > 1.1) {
            break;
          }
          if (abs(pos-translate).z > 1.1) {
            break;
          }
          p = pos-translate;
          float dist = distance(p);
          if (dist < max(eps * abs(pos.z), eps)) {
            hit = true;
            break;
          }
          count += 0.02;
          pos += 0.7 * dir * dist;
        }
        float red = 0.;
        float blue = count;
        float u = max(eps * abs(pos.z), eps);
        if (hit) {
          vec3 normal = normalize(gradient(p));
          vec3 lightdir = pos - vec3(0, 0, -2);
          vec3 nlightdir = normalize(lightdir);
          vec3 lightdir2 = pos - vec3(4, 0, -5);
          vec3 nlightdir2 = normalize(lightdir2);
          vec3 lightdir3 = pos - vec3(-4, 0, -5);
          vec3 nlightdir3 = normalize(lightdir3);
          float intensity = clamp(-dot(nlightdir, normal), 0.0, 1.0);
          float intensity2 = clamp(-dot(nlightdir2, normal)/
              length(lightdir2), 0.0, 1.0);
          float intensity3 = clamp(-dot(nlightdir3, normal)/
              length(lightdir3), 0.0, 1.0);
          float spec =pow(clamp(-dot(normalize(dir),
              reflect(nlightdir, normal)), 0.0, 1.0), 80.0);
          float spec2 =pow(clamp(-dot(normalize(dir),
              reflect(nlightdir2, normal)), 0.0, 1.0), 80.0);
          float spec3 =pow(clamp(-dot(normalize(dir),
              reflect(nlightdir3, normal)), 0.0, 1.0), 80.0);
//          gl_FragColor = vec4(normal-normalize(exactGradient(p)), 1);

            gl_FragColor = vec4(intensity +intensity3+ spec+spec3,
                intensity +spec, intensity +intensity2+ spec+spec2, 1.0);
        } else {
          if (debug) {
            gl_FragColor = vec4(vec3(count),1.);
          } else {
            discard;
          }
        }
      }

      vec4 multiply(vec4 a, vec4 b) {
        return vec4(
            a.w * b.x + a.x * b.w,
            a.w * b.y + a.y * b.w,
            a.w * b.z + a.z * b.w,
            a.w * b.w);
      }

      vec4 squareRoot(vec4 a) {
        float s = sqrt(a.w);
        return vec4(a.x/s/2., a.y/s/2., a.z/s/2., s);
      }

      float box(vec3 pos);
      float sphere(vec3 pos);
      float torus(vec3 pos);

      vec3 boxGradient(vec3 pos);
      vec3 sphereGradient(vec3 pos);
      vec3 torusGradient(vec3 pos);

      float distance(vec3 pos) {
        return box(pos);
      }

      vec3 gradient(vec3 pos) {
//      if (debug) {
          return approximateGradient(pos);
//      } else {
//        return exactGradient(pos);
//      }
      }

      vec3 approximateGradient(vec3 pos) {
        float u = 0.1;
        vec3 dx = vec3(u, 0.0, 0.0);
        vec3 dy = vec3(0.0, u, 0.0);
        vec3 dz = vec3(0.0, 0.0, u);
        return vec3(
            distance(pos+dx) - distance(pos-dx),
            distance(pos+dy) - distance(pos-dy),
            distance(pos+dz) - distance(pos-dz));
      }

      vec3 exactGradient(vec3 pos) {
        return boxGradient(pos);
      }

      float box(vec3 pos) {
//      float right = dot(pos,vec3(1.,0.,0.))-0.25;
//      float left = dot(pos, vec3(-1.,0.,0.))-0.25;
//      float top = dot(pos,vec3(0.,1.,0.))-0.25;
//      float bottom = dot(pos, vec3(0.,-1.,0.))-0.25;
//      float front = dot(pos,vec3(0.,0.,1.))-0.25;
//      float back = dot(pos, vec3(0.,0.,-1.))-0.25;
//      return max(max(max(right,left),max(top,bottom)),max(front,back))-0.1;
        return length(max(abs(pos)-vec3(0.5),0.))-.5;
      }

      float sphere(vec3 pos) {
        return length(pos)-sqrt(0.5);
      }

      float torus(vec3 pos) {
        return length(vec2(length(pos.xz)-R,pos.y))-r;
      }

      vec4 maximum(vec4 a, vec4 b) {
        return mix(a, b, vec4(a.w<b.w));
      }

      vec3 boxGradient(vec3 pos) {
        vec4 x = vec4(1, 0, 0, pos.x);
        vec4 y = vec4(0, 1, 0, pos.y);
        vec4 z = vec4(0, 0, 1, pos.z);
        vec4 left = x-vec4(0,0,0,.25);
        vec4 right = -x-vec4(0,0,0,.25);
        vec4 top = y-vec4(0,0,0,.25);
        vec4 bottom = -y-vec4(0,0,0,.25);
        vec4 front = z-vec4(0,0,0,.25);
        vec4 back = -z-vec4(0,0,0,.25);
        return (maximum(maximum(maximum(right,left),maximum(top,bottom)),
            maximum(front,back))-vec4(0,0,0,0.1)).xyz;
      }

      vec3 sphereGradient(vec3 pos) {
        vec4 x = vec4(1, 0, 0, pos.x);
        vec4 y = vec4(0, 1, 0, pos.y);
        vec4 z = vec4(0, 0, 1, pos.z);
        return (squareRoot(multiply(x,x) + multiply(y,y) + multiply(z,z))
            - vec4(0, 0, 0, sqrt(0.5))).xyz;
      }

      vec3 torusGradient(vec3 pos) {
        vec4 x = vec4(1, 0, 0, pos.x);
        vec4 y = vec4(0, 1, 0, pos.y);
        vec4 z = vec4(0, 0, 1, pos.z);
        vec4 d = squareRoot(multiply(x,x)+multiply(z,z))-vec4(0,0,0,R);
        return (squareRoot(multiply(d,d)+multiply(y,y))-vec4(0,0,0,r)).xyz;
      }
    </script>
  </head>
  <body onload="ray.load();">
    <div style="float: left;">
      <canvas id="c"></canvas>
    </div>
    <p><b>Controls</b></p>
    <table>
      <tr><th>Shape Translation</th></tr>
      <tr><td><b>d</b></td><td>Positive X.</td></tr>
      <tr><td><b>a</b></td><td>Negative X.</td></tr>
      <tr><td><b>w</b></td><td>Positive Y.</td></tr>
      <tr><td><b>s</b></td><td>Negative Y.</td></tr>
      <tr><td><b>z</b></td><td>Positive Z.</td></tr>
      <tr><td><b>q</b></td><td>Negative Z.</td></tr>
      <tr><th>Shape Selection</th></tr>
      <tr><td><b>n</b></td><td>Next shape.</td></tr>
      <tr><td><b>p</b></td><td>Previous shape.</td></tr>
      <tr><th>Debug Modes</th></tr>
      <tr><td><b>y</b></td><td>Toggle loops per fragment display.</td></tr>
      <tr><td><b>u</b></td><td>Toggle "eye tracker" level-of-detail display.</td></tr>
      <tr><td><b>i</b></td><td>Toggle intersector mesh.</td></tr>
    </table>
  </body>
</html>
